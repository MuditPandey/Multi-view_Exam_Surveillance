//opencv
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/imgproc/imgproc.hpp>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

//global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
int keyboard;
int update_bg_model = 1;
//function declarations
void processVideo(char* videoFilename);
Ptr<BackgroundSubtractorMOG2> b;

static void refineSegments(Mat frame,Mat &img)
{
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;
	Mat temp;
	int niters = 3;
	//dilate(img, temp, Mat(), Point(-1, -1), niters);
	//erode(temp, temp, Mat(), Point(-1, -1), niters * 2);
	//dilate(temp, temp, Mat(), Point(-1, -1), niters);
	findContours(img, contours, hierarchy, RETR_LIST, CHAIN_APPROX_NONE);
	//Mat dst = Mat::zeros(img.size(), CV_8UC3);
	if (contours.size() == 0)
	{
		cout << "empty";
		return;
	}
	// iterate through all the top-level contours,
	// draw each connected component with its own random color
	vector<vector<Point> > contours_poly(contours.size());
	vector<Rect> boundRect(contours.size());
	vector<Point2f>center(contours.size());
	vector<float>radius(contours.size());
	for (int i = 0; i < contours.size(); i++)
	{
		boundRect[i] = boundingRect(Mat(contours[i]));
		minEnclosingCircle((Mat)contours[i], center[i], radius[i]);
	}


	/// Draw polygonal contour + bonding rects + circles
	for (int i = 0; i< contours.size(); i++)
	{
		//drawContours(frame, contours, i, Scalar(0,0,255), 1, 8, vector<Vec4i>(), 0, Point());
		rectangle(frame, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 0, 255), 2, 8, 0);
		circle(frame, center[i], (int)radius[i], Scalar(0, 0, 255), 2, 8, 0);
	}
	imshow("exa", frame);
	//Scalar color(0, 0, 255);
	//drawContours(dst, contours, largestComp, color, FILLED, LINE_8, hierarchy);
}

int main(int argc, char* argv[])
{
	

	//create GUI windows
	namedWindow("Frame");
	namedWindow("FG Mask MOG 2");
	//create Background Subtractor objects
	b = createBackgroundSubtractorMOG2(100,70.5,false);
	//b->setVarThreshold(10);
	processVideo("Video_001.avi");
	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
	//create the capture object
	//nt ch;
	//cin >> ch;
	VideoCapture capture(videoFilename);
	if (!capture.isOpened()) {
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		//exit(EXIT_FAILURE);
	}
	//read input data. ESC or 'q' for quitting
	while ((char)keyboard != 'q' && (char)keyboard != 27) {
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			//exit(EXIT_FAILURE);
		}
		//update the background model
		//circle(frame, Point2f(11,32), 3.2, Scalar(0, 0, 255), 1, LINE_AA);
		b->apply(frame, fgMaskMOG2, update_bg_model ? -1 : 0);
		Mat element = getStructuringElement(MORPH_RECT, Size(5, 5));
		//morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_OPEN,element);
		//element = getStructuringElement(MORPH_RECT, Size(11, 11));
		//morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_CLOSE, element,Point(-1,-1),3);
		//refineSegments(frame,fgMaskMOG2);
		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(255, 255, 255), -1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0));
		//show the current frame and the fg masks
		imshow("Frame", frame);
		imshow("FG Mask MOG 2", fgMaskMOG2);
		//get the input from the keyboard
		keyboard = waitKey(30);
	}
	//delete capture object
	capture.release();
}
