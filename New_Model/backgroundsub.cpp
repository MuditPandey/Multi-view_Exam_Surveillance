/*
//opencv
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/imgproc/imgproc.hpp>
//C++
#include <iostream>
#include <fstream>
#include <sstream>
#include  <math.h>
#define IGNORE_THRESH 600
#define PROXIMITY 30
using namespace cv;
using namespace std;

//global variables
struct ignore
{
	Point2d prev;
	Point2d cur;
	bool flag;
	ignore(Point2d pe,Point2d ce,bool fl)
	{
		cur = ce;
		prev = pe;
		flag = fl;
	}
};
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
int keyboard;
int update_bg_model = 0;
//function declarations
void processVideo(char* videoFilename);
Ptr<BackgroundSubtractorMOG2> b;
vector<int> frame_numbers;
vector<double> frame_time;
vector<ignore> ignore_set;
string s;
bool exist(vector<vector<Point> >,Point2f);
bool nearby(Point2d fin, Point2d init, double e);

bool refineSegments(Mat dif,Mat &img)
{
	int area_thresh = 250;
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;
	vector<vector<Point> > contours_diff;
	vector<Vec4i> hierarchy_diff;
	bool flag = false;
	Mat temp = dif.clone();
	findContours(temp, contours_diff, hierarchy_diff, RETR_LIST, CHAIN_APPROX_NONE);
	findContours(img, contours, hierarchy, RETR_LIST, CHAIN_APPROX_NONE);
	// A few frames generate a huge number of contours but due to noise. Unnecessarily slows down the program. Therefore ignore frames where a large number of contours are generated i.e >100
	if (contours.size() == 0 || contours.size()>100)
	{
		cout << "empty";
		return false;
	}
	// iterate through all the top-level contours,
	vector<Rect> boundRect;
	double sum = 0;

	for (int i = 0; i < contours.size(); i++)
	{
		double area = fabs(contourArea(Mat(contours[i])));
		//	sum += area;
		Moments mu;
		mu = moments(contours[i], false);
		///  Get the mass centers:
		Point2d mc;
		mc = Point2d(mu.m10 / mu.m00, mu.m01 / mu.m00);
		//Should be replaced by ROI
		if (mc.x < 50|| mc.x>550 || mc.y>400)
		{
			if (exist(contours_diff, mc) == false)
			{
				ignore nd(mc,mc,false);
				ignore_set.push_back(nd);
			}
		}
		if (exist(contours_diff, mc) == true)
			continue;
		if (area >area_thresh)
		{
			boundRect.push_back(boundingRect(Mat(contours[i])));
			//minEnclosingCircle((Mat)contours[i], center[i], radius[i]);
		}
	}

	/// Draw polygonal contour + bonding rects + circles
	if (boundRect.size() > 0)
		flag = true;
	for (int i = 0; i< boundRect.size(); i++)
	{
		//drawContours(frame, contours, i, Scalar(0,0,255), 1, 8, vector<Vec4i>(), 0, Point());
		rectangle(frame, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 0, 255), 2, 8, 0);
		//circle(frame, center[i], (int)radius[i], Scalar(0, 0, 255), 2, 8, 0);
	}
	return flag;
	//imshow("exa", frame);
	//Scalar color(0, 0, 255);
	//drawContours(dst, contours, largestComp, color, FILLED, LINE_8, hierarchy);
}

int main(int argc, char* argv[])
{


	//create GUI windows
	//namedWindow("Frame");
	//namedWindow("FG Mask MOG 2");
	//create Background Subtractor objects

	b = createBackgroundSubtractorMOG2(100,25,false);
	//b->setVarThreshold(10);
	processVideo("ac"); //G106_cam2_take1.mp4 //G106_cam2_take3.mp4
	fstream f;
	f.open("frames.txt",ios::out);
	for (int i = 0; i < frame_numbers.size(); i++)
		f << frame_numbers[i] <<endl;
	f.close();
	f.open("Time.txt", ios::out);
	for (int i = 0; i < frame_time.size(); i++)
		f << frame_time[i] << endl;
	f.close();
	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}
void processVideo(char* videoFilename) {

		int pre = -9;
		Mat prev_frame;
		VideoCapture capture("G102_cam2_take3_beginappended.mp4");
		int ex = static_cast<int>(capture.get(CV_CAP_PROP_FOURCC));
		if (!capture.isOpened()) {
			//error in opening the video input
			cerr << "Unable to open video file: " << videoFilename << endl;
			return;
			//exit(EXIT_FAILURE);
		}
		//char EXT[] = { (char)(ex & 0XFF) , (char)((ex & 0XFF00) >> 8),(char)((ex & 0XFF0000) >> 16),(char)((ex & 0XFF000000) >> 24), 0 };
		//cout << EXT;
		Size S = Size((int)capture.get(CV_CAP_PROP_FRAME_WIDTH), (int)capture.get(CV_CAP_PROP_FRAME_HEIGHT));	
		VideoWriter outputVideo;
		outputVideo.open("Entire_model2.avi", CV_FOURCC('X', 'V', 'I', 'D'), capture.get(CV_CAP_PROP_FPS), S, true);
		if (!outputVideo.isOpened())
		{
			cout << "Could not open the output video for write: " <<endl;
			//return;
		}
		//read input data. ESC or 'q' for quitting
		while ((char)keyboard != 'q' && (char)keyboard != 27) {
			//read the current frame
			if (!capture.read(frame)) {
				cerr << "Unable to read next frame.2" << endl;
				cerr << "Exiting..." << endl;
				//exit(EXIT_FAILURE);
				break;
			}
			//if (capture.get(CAP_PROP_POS_FRAMES) > 200)
				//break;
			//*****
			//Mat mogframe(frame);
			Mat cur_frame = frame.clone();
			Mat cur_frame_gs, prev_frame_gs,diff_frame;
			if (capture.get(CAP_PROP_POS_FRAMES) > 1)
			{
				cvtColor(cur_frame,cur_frame_gs, COLOR_BGR2GRAY);
				//imshow("cur frame",cur_frame_gs);
				cvtColor(prev_frame,prev_frame_gs, COLOR_BGR2GRAY);
				//imshow("prev frame", prev_frame_gs);
				subtract(prev_frame_gs, cur_frame_gs,diff_frame);
				//imshow("diff", diff_frame);
				Mat element2 = getStructuringElement(MORPH_RECT, Size(3, 3));
				morphologyEx(diff_frame, diff_frame, MORPH_ERODE, element2, Point(-1, -1), 3);
				threshold(diff_frame, diff_frame, 15, 255, THRESH_BINARY);
				//imshow("diff", diff_frame);
			}
			b->apply(frame, fgMaskMOG2,0.008);
			Mat element = getStructuringElement(MORPH_RECT, Size(3, 3));
			morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_DILATE, element);
			morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_ERODE, element, Point(-1, -1), 2);
			//element = getStructuringElement(MORPH_RECT, Size(11, 11));
			//morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_CLOSE, element, Point(-1, -1), 1);
			if (pre + 10 == capture.get(CAP_PROP_POS_FRAMES))
			{
				prev_frame = frame.clone();
				pre += 10;
			}
			if (refineSegments(diff_frame,fgMaskMOG2)==true)
			{
				frame_numbers.push_back((int)capture.get(CAP_PROP_POS_FRAMES));
				frame_time.push_back(capture.get(CAP_PROP_POS_MSEC));
			}
			//get the frame number and write it on the current frame*/
            /*
			stringstream ss;
			ss << capture.get(CAP_PROP_POS_FRAMES);
			rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
				cv::Scalar(255, 255, 255), -1);
			string frameNumberString = ss.str() + " MOG2";
			putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
				FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0));
			//show the current frame and the fg masks
			outputVideo << frame;
			imshow("FG Mask MOG 2", fgMaskMOG2);
			imshow("MogFrame",frame);
			keyboard = waitKey(30);
		}
		capture.release();
			/***
			Mat element = (cv::Mat_<uchar>(5, 5) <<
				0, 0, 1, 0, 0,
				0, 3, 5, 3, 0,
				1, 3, 5, 3, 1,
				0, 3, 5, 3, 0,
				0, 0, 1, 0, 0);
			Mat element2 = (cv::Mat_<uchar>(5, 5) <<
				0, 0, 1, 0, 0,
				0, 1, 1, 1, 0,
				1, 1, 1, 1, 1,
				0, 1, 1, 1, 0,
				0, 0, 1, 0, 1);
			//Mat element = getStructuringElement(CV_SHAPE_CUSTOM, Size(7, 7),Point(-1,-1	));
			Mat oframe, frame2, refframe2;
			cvtColor(manualframe, frame2, COLOR_BGR2GRAY);
			//imshow("Greyscal frame",frame2);
			cvtColor(refframe, refframe2, COLOR_BGR2GRAY);
			//imshow("refframe", refframe2);
			subtract(refframe2,frame2, oframe);
			imshow("Greyscal Subtraction", oframe);
			//morphologyEx(oframe, oframe, MORPH_ERODE, element, Point(-1, -1), 1);
			//filter2D(oframe, oframe, -1, element);
			morphologyEx(oframe, oframe, MORPH_ERODE, element2, Point(-1, -1), 1);
			imshow("Dilation after subtraction", oframe);
			threshold(oframe, oframe,30, 255, THRESH_BINARY); //200
			imshow("After threshold", oframe);
			Mat element3 = getStructuringElement(MORPH_RECT, Size(3, 3));
			morphologyEx(oframe, oframe, MORPH_DILATE, element3, Point(-1, -1),1);
			imshow("Erosion after threshold", oframe);
			//element = getStructuringElement(MORPH_RECT, Size(7, 7));
			//morphologyEx(oframe, oframe, MORPH_CLOSE, element);
			morphologyEx(oframe, oframe, MORPH_OPEN, element2, Point(-1, -1), 1);
			imshow("Before refifining", oframe);
			refineSegments(manualframe, oframe);
			stringstream pp;
			rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
				cv::Scalar(255, 255, 255), -1);
			pp << capture.get(CAP_PROP_POS_FRAMES);
			string frameNumberString2 = pp.str()+" MANUAL";
			putText(manualframe, frameNumberString2.c_str(), cv::Point(15, 15),
				FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0));
			//show the current frame and the fg masks
			imshow("Frame", manualframe);
			imshow("OFrame", oframe);
			//roi = Mat(merged_frame, Rect(0,480, 640, 480));
			//manualframe.copyTo(roi);
			//roi = Mat(merged_frame, Rect(640, 480, 640, 480));
			//oframe.copyTo(roi);
			//result << merged_frame;
			//get the input from the keyboard
			keyboard = waitKey(30);
		}
		//delete capture object
		capture.release();

	/*USING MOG2
	VideoCapture capture("G106_cam2_take3_10mins.mp4");
		if (!capture.isOpened()) {
			//error in opening the video input
			cerr << "Unable to open video file: " << videoFilename << endl;
			//exit(EXIT_FAILURE);
		}
		//read input data. ESC or 'q' for quitting
		while ((char)keyboard != 'q' && (char)keyboard != 27) {
			//read the current frame
			if (!capture.read(frame)) {
				cerr << "Unable to read next frame.2" << endl;
				cerr << "Exiting..." << endl;
				//exit(EXIT_FAILURE);
				break;
			}
			//update the background model
			//circle(frame, Point2f(11,32), 3.2, Scalar(0, 0, 255), 1, LINE_AA);
			b->apply(frame, fgMaskMOG2, 0);
		Mat element = getStructuringElement(MORPH_RECT, Size(3, 3));
		//morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_DILATE, element);
		morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_OPEN,element);
		//element = getStructuringElement(MORPH_RECT, Size(11, 11));
		morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_CLOSE, element,Point(-1,-1),3);
		refineSegments(frame,fgMaskMOG2);
		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(255, 255, 255), -1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0));
		//show the current frame and the fg masks
		imshow("Frame", frame);
		imshow("FG Mask MOG 2", fgMaskMOG2);
		//get the input from the keyboard
		keyboard = waitKey(30);
	}
	//delete capture object
	capture.release();*/
//}
/*
bool exist(vector< vector<Point> > ct,Point2f refer)
{

	if (ignore_set.empty())
		return false;
	for (int i = 0; i < ignore_set.size(); i++)
	{
		if (nearby(refer, ignore_set[i].cur,PROXIMITY))
		{
			ignore_set[i].c=refer;
			return true;
		}
	}
	return false;
}

bool nearby(Point2d fin, Point2d init, double e)
{
	if (sqrt((fin.x - init.x)*(fin.x - init.x) + (fin.y - init.y)*(fin.y - init.y)) <= e)
		return true;
	return false;
}
*/
